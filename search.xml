<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>linux学习笔记</title>
      <link href="/2021/10/22/linux-xue-xi-bi-ji/"/>
      <url>/2021/10/22/linux-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h1><h2 id="1-关机操作"><a href="#1-关机操作" class="headerlink" title="1.关机操作"></a>1.关机操作</h2><p>关机指令为：shutdown ；</p><blockquote><p>ync # 将数据由内存同步到硬盘中。<br>shutdown # 关机指令，你可以man shutdown 来看一下帮助文档。例如你可以运行如下命令关机：<br>shutdown –h 10 # 这个命令告诉大家，计算机将在10分钟后关机<br>shutdown –h now # 立马关机<br>shutdown –h 20:25 # 系统会在今天20:25关机<br>shutdown –h +10 # 十分钟后关机<br>shutdown –r now # 系统立马重启<br>shutdown –r +10 # 系统十分钟后重启<br>reboot # 就是重启，等同于 shutdown –r now<br>halt # 关闭系统，等同于shutdown –h now 和 poweroff</p></blockquote><p>不管是重启系统还是关闭系统，首先要运行 sync 命令，把内存中的数据写到磁盘中。</p><blockquote><p>登录系统后，在当前命令窗口下输入命令：ls<br><img src="https://edu-2539.oss-cn-beijing.aliyuncs.com/linux%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87/snipaste_20211022_183001.png" alt="image"></p></blockquote><p><img src="https://edu-2539.oss-cn-beijing.aliyuncs.com/linux%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87/640.webp" alt="image"></p><p>以下是对这些目录的解释：</p><ul><li><p>/bin：bin是Binary的缩写, 这个目录存放着最经常使用的命令。</p></li><li><p>/boot： 这里存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。</p></li><li><p>/dev ： dev是Device(设备)的缩写, 存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的。</p></li><li><p>/etc： 这个目录用来存放所有的系统管理所需要的配置文件和子目录。</p></li><li><p>/home：用户的主目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。</p></li><li><p>/lib：这个目录里存放着系统最基本的动态连接共享库，其作用类似于Windows里的DLL文件。</p></li><li><p>/lost+found：这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。</p></li><li><p>/media：linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。</p></li><li><p>/mnt：系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/上，然后进入该目录就可以查看光驱里的内容了。</p></li><li><p>/opt：这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。</p></li><li><p>/proc：这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。</p></li><li><p>/root：该目录为系统管理员，也称作超级权限者的用户主目录。</p></li><li><p>/sbin：s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。</p></li><li><p>/srv：该目录存放一些服务启动之后需要提取的数据。</p></li><li><p>/sys：这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。</p></li><li><p>/tmp：这个目录是用来存放一些临时文件的。</p></li><li><p>/usr：这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。</p></li><li><p>/usr/bin： 系统用户使用的应用程序。</p></li><li><p>/usr/sbin： 超级用户使用的比较高级的管理程序和系统守护程序。</p></li><li><p>/usr/src： 内核源代码默认的放置目录。</p></li><li><p>/var：这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。</p></li><li><p>/run：是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。</p></li></ul><h1 id="linux-基本命令"><a href="#linux-基本命令" class="headerlink" title="linux 基本命令"></a>linux 基本命令</h1><blockquote><p>处理目录的常用命令</p></blockquote><ul><li><p>ls: 列出目录</p></li><li><p>cd：切换目录</p></li><li><p>pwd：显示目前的目录</p></li><li><p>mkdir：创建一个新的目录</p></li><li><p>dir：删除一个空的目录</p></li><li><p>: 复制文件或目录</p></li><li><p>: 移除文件或目录</p></li><li><p>: 移动文件与目录，或修改文件与目录的名称</p></li></ul><blockquote><p>ls(列出列表）</p></blockquote><p>选项与参数：</p><p>-a ：全部的文件，连同隐藏文件( 开头为 . 的文件) 一起列出来(常用)</p><p>-l ：长数据串列出，包含文件的属性与权限等等数据；(常用)</p><p>将目录下的所有文件列出来(含属性与隐藏档)</p><blockquote><p>cd 目录<br>pwd 显示当前所在目录<br>pwd -P 显示当前确实的路径</p></blockquote><blockquote><p>mkdir 创建文件目录<br>选项与参数：<br>-m ：配置文件的权限喔！直接配置，不需要看默认权限 (umask) 的脸色～<br>-p ：帮助你直接将所需要的目录(包含上一级目录)递归创建起来！</p></blockquote><p>测试：</p><pre><code># 进入我们用户目录下[root@kuangshen /]# cd /home# 创建一个 test 文件夹[root@kuangshen home]# mkdir test# 创建多层级目录[root@kuangshen home]# mkdir test1/test2/test3/test4mkdir: cannot create directory ‘test1/test2/test3/test4’:No such file or directory  # &lt;== 没办法直接创建此目录啊！# 加了这个 -p 的选项，可以自行帮你创建多层目录！[root@kuangshen home]# mkdir -p test1/test2/test3/test4# 创建权限为 rwx--x--x 的目录。[root@kuangshen home]# mkdir -m 711 test2[root@kuangshen home]# ls -ldrwxr-xr-x 2 root root  4096 Mar 12 21:55 testdrwxr-xr-x 3 root root  4096 Mar 12 21:56 test1drwx--x--x 2 root root  4096 Mar 12 21:58 test2</code></pre><blockquote><p>rmdir (删除空的目录)<br>rmdir [-p] 目录名称选项与参数：-p ：连同上一级『空的』目录也一起删除</p></blockquote><blockquote><p>cp 文件复制<br>[root@www ~]# cp [-adfilprsu] 来源档(source) 目标档(destination)<br>[root@www ~]# cp [options] source1 source2 source3 …. directory</p></blockquote><p>选项与参数：</p><p>-a：相当於 -pdr 的意思，至於 pdr 请参考下列说明；(常用)</p><p>-p：连同文件的属性一起复制过去，而非使用默认属性(备份常用)；</p><p>-d：若来源档为连结档的属性(link file)，则复制连结档属性而非文件本身；</p><p>-r：递归持续复制，用於目录的复制行为；(常用)</p><p>-f：为强制(force)的意思，若目标文件已经存在且无法开启，则移除后再尝试一次；</p><p>-i：若目标档(destination)已经存在时，在覆盖时会先询问动作的进行(常用)</p><p>-l：进行硬式连结(hard link)的连结档创建，而非复制文件本身。</p><p>-s：复制成为符号连结档 (symbolic link)，亦即『捷径』文件；</p><p>-u：若 destination 比 source 旧才升级 destination ！</p><blockquote><p>rm ( 移除文件或目录 )<br>选项与参数：</p></blockquote><p>-f ：就是 force 的意思，忽略不存在的文件，不会出现警告信息；</p><p>-i ：互动模式，在删除前会询问使用者是否动作</p><p>-r ：递归删除啊！最常用在目录的删除了！这是非常危险的选项！！！</p><blockquote><p>mv &nbsp;( 移动文件与目录，或修改名称 )</p></blockquote><p>[root@www ~]# mv [-fiu] source destination<br>[root@www ~]# mv [options] source1 source2 source3 …. directory</p><p>选项与参数：</p><p>-f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；</p><p>-i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！</p><p>-u ：若目标文件已经存在，且 source 比较新，才会升级 (update)</p><p>测试：</p><pre><code># 复制一个文件到当前目录[root@kuangshen home]# cp /root/install.sh /home# 创建一个文件夹 test[root@kuangshen home]# mkdir test# 将复制过来的文件移动到我们创建的目录，并查看[root@kuangshen home]# mv install.sh test[root@kuangshen home]# lstest[root@kuangshen home]# cd test[root@kuangshen test]# lsinstall.sh# 将文件夹重命名，然后再次查看！[root@kuangshen test]# cd ..[root@kuangshen home]# mv test mvtest[root@kuangshen home]# lsmvtest</code></pre><blockquote><p>基本属性</p></blockquote><p>Linux系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。为了保护系统的安全性，Linux系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定。在Linux中我们可以使用ll或者ls –l命令来显示一个文件的属性以及文件所属的用户和组，如：</p><p><img src="https://edu-2539.oss-cn-beijing.aliyuncs.com/linux%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87/snipaste_20211022_184951.png" alt="image"></p><p>实例中，boot文件的第一个属性用”d”表示。”d”在Linux中代表该文件是一个目录文件。</p><p>在Linux中第一个字符代表这个文件是目录、文件或链接文件等等：</p><p>当为[ d ]则是目录</p><p>当为[ - ]则是文件；</p><p>若是[ l ]则表示为链接文档 ( link file )；</p><p>若是[ b ]则表示为装置文件里面的可供储存的接口设备 ( 可随机存取装置 )；</p><p>若是[ c ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标 ( 一次性读取装置 )。</p><p>接下来的字符中，以三个为一组，且均为『rwx』 的三个参数的组合。</p><p>其中，[ r ]代表可读(read)、[ w ]代表可写(write)、[ x ]代表可执行(execute)。</p><p>要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号[ - ]而已。</p><p>每个文件的属性由左边第一部分的10个字符来确定（如下图）：<br><img src="https://edu-2539.oss-cn-beijing.aliyuncs.com/linux%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87/640%20%281%29.webp" alt="image"><br>从左至右用0-9这些数字来表示。</p><p>第0位确定文件类型，第1-3位确定属主（该文件的所有者）拥有该文件的权限。第4-6位确定属组（所有者的同组用户）拥有该文件的权限，第7-9位确定其他用户拥有该文件的权限。</p><p>其中：</p><p>第1、4、7位表示读权限，如果用”r”字符表示，则有读权限，如果用”-“字符表示，则没有读权限；</p><p>第2、5、8位表示写权限，如果用”w”字符表示，则有写权限，如果用”-“字符表示没有写权限；</p><p>第3、6、9位表示可执行权限，如果用”x”字符表示，则有执行权限，如果用”-“字符表示，则没有执行权限。</p><p>对于文件来说，它都有一个特定的所有者，也就是对该文件具有所有权的用户。</p><p>同时，在Linux系统中，用户是按组分类的，一个用户属于一个或多个组。</p><p>文件所有者以外的用户又可以分为文件所有者的同组用户和其他用户。</p><p>因此，Linux系统按文件所有者、文件所有者同组用户和其他用户来规定了不同的文件访问权限。</p><p>在以上实例中，boot 文件是一个目录文件，属主和属组都为 root。</p><blockquote><p>修改文件属性<br>1、chgrp：更改文件属组</p></blockquote><p>chgrp [-R] 属组名 文件名<br>-R：递归更改文件属组，就是在更改某个目录文件的属组时，如果加上-R的参数，那么该目录下的所有文件的属组都会更改。</p><p>2、chown：更改文件属主，也可以同时更改文件属组</p><p>chown [–R] 属主名 文件名<br>chown [-R] 属主名：属组名 文件名<br>3、chmod：更改文件9个属性</p><p>chmod [-R] xyz 文件或目录<br>Linux文件属性有两种设置方法，一种是数字，一种是符号。</p><p>Linux文件的基本权限就有九个，分别是owner/group/others三种身份各有自己的read/write/execute权限。</p><p>先复习一下刚刚上面提到的数据：文件的权限字符为：『-rwxrwxrwx』， 这九个权限是三个三个一组的！其中，我们可以使用数字来代表各个权限，各权限的分数对照表如下：</p><p>r:4     w:2         x:1<br>每种身份(owner/group/others)各自的三个权限(r/w/x)分数是需要累加的，例如当权限为：[-rwxrwx—] 分数则是：</p><p>owner = rwx = 4+2+1 = 7</p><p>group = rwx = 4+2+1 = 7</p><p>others= — = 0+0+0 = 0</p><p>chmod 770 filename</p><h1 id="文件内容查看"><a href="#文件内容查看" class="headerlink" title="文件内容查看"></a>文件内容查看</h1><blockquote><p>概述</p></blockquote><p>Linux系统中使用以下命令来查看文件的内容：</p><p>cat 由第一行开始显示文件内容</p><p>tac 从最后一行开始显示，可以看出 tac 是 cat 的倒着写！</p><p>nl  显示的时候，顺道输出行号！</p><p>more 一页一页的显示文件内容</p><p>less 与 more 类似，但是比 more 更好的是，他可以往前翻页！</p><p>head 只看头几行</p><p>tail 只看尾巴几行</p><p>你可以使用 man [命令]来查看各个命令的使用文档，如 ：man cp。</p><p>cat 由第一行开始显示文件内容</p><blockquote><p>语法：</p></blockquote><p>cat [-AbEnTv]<br>选项与参数：</p><p>-A ：相当於 -vET 的整合选项，可列出一些特殊字符而不是空白而已；</p><p>-b ：列出行号，仅针对非空白行做行号显示，空白行不标行号！</p><p>-E ：将结尾的断行字节 $ 显示出来；</p><p>-n ：列印出行号，连同空白行也会有行号，与 -b 的选项不同；</p><p>-T ：将 [tab] 按键以 ^I 显示出来；</p><p>-v ：列出一些看不出来的特殊字符</p><p>测试：</p><pre><code># 查看网络配置: 文件地址 /etc/sysconfig/network-scripts/[root@kuangshen ~]# cat /etc/sysconfig/network-scripts/ifcfg-eth0DEVICE=eth0BOOTPROTO=dhcpONBOOT=yes</code></pre><blockquote><p>tac</p></blockquote><p>tac与cat命令刚好相反，文件内容从最后一行开始显示，可以看出 tac 是 cat 的倒着写！如：</p><pre><code>[root@kuangshen ~]# tac /etc/sysconfig/network-scripts/ifcfg-eth0ONBOOT=yesBOOTPROTO=dhcpDEVICE=eth0</code></pre><blockquote><p>nl &nbsp;显示行号</p></blockquote><p>语法：nl [-bnw] 文件<br>选项与参数：</p><p>-b ：指定行号指定的方式，主要有两种：-b a ：表示不论是否为空行，也同样列出行号(类似 cat -n)；-b t ：如果有空行，空的那一行不要列出行号(默认值)；</p><p>-n ：列出行号表示的方法，主要有三种：-n ln ：行号在荧幕的最左方显示；-n rn ：行号在自己栏位的最右方显示，且不加 0 ；-n rz ：行号在自己栏位的最右方显示，且加 0 ；</p><p>-w ：行号栏位的占用的位数。</p><p>测试：</p><p>[root@kuangshen ~]# nl /etc/sysconfig/network-scripts/ifcfg-eth0<br>1DEVICE=eth0<br>2BOOTPROTO=dhcp<br>3ONBOOT=yes</p><blockquote><p>more  一页一页翻动</p></blockquote><p>在 more 这个程序的运行过程中，你有几个按键可以按的：</p><p>空白键 (space)：代表向下翻一页；</p><p>Enter     ：代表向下翻『一行』；</p><p>/字串     ：代表在这个显示的内容当中，向下搜寻『字串』这个关键字；</p><p>:f      ：立刻显示出档名以及目前显示的行数；</p><p>q       ：代表立刻离开 more ，不再显示该文件内容。</p><p>b 或 [ctrl]-b ：代表往回翻页，不过这动作只对文件有用，对管线无用。</p><pre><code>[root@kuangshen etc]# more /etc/csh.login....(中间省略)....--More--(28%) # 重点在这一行喔！你的光标也会在这里等待你的命令</code></pre><blockquote><p>less   一页一页翻动，以下实例输出/etc/man.config文件的内容：</p></blockquote><p>less运行时可以输入的命令有：</p><p>空白键  ：向下翻动一页；</p><p>[pagedown]：向下翻动一页；</p><p>[pageup] ：向上翻动一页；</p><p>/字串   ：向下搜寻『字串』的功能；</p><p>?字串   ：向上搜寻『字串』的功能；</p><p>n     ：重复前一个搜寻 (与 / 或 ? 有关！)</p><p>N     ：反向的重复前一个搜寻 (与 / 或 ? 有关！)</p><p>q     ：离开 less 这个程序；</p><pre><code>[root@kuangshen etc]# more /etc/csh.login....(中间省略)....:   # 这里可以等待你输入命令！</code></pre><blockquote><p>head  取出文件前面几行</p></blockquote><p>语法：</p><p>head [-n number] 文件<br>选项与参数：-n 后面接数字，代表显示几行的意思！</p><p>默认的情况中，显示前面 10 行！若要显示前 20 行，就得要这样：</p><p>[root@kuangshen etc]# head -n 20 /etc/csh.login</p><p>tail  取出文件后面几行</p><p>语法：</p><p>tail [-n number] 文件<br>选项与参数：</p><p>-n ：后面接数字，代表显示几行的意思</p><p>默认的情况中，显示最后 10 行！若要显示最后 20 行，就得要这样：</p><p>[root@kuangshen etc]# tail -n 20 /etc/csh.login</p><blockquote><p>拓展：Linux 链接概念</p></blockquote><p>Linux 链接分两种，一种被称为硬链接（Hard Link），另一种被称为符号链接（Symbolic Link）。</p><p>情况下，ln 命令产生硬链接。</p><p>硬连接</p><p>硬连接指通过索引节点来进行连接。在 Linux 的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode Index)。在 Linux 中，多个文件名指向同一索引节点是存在的。比如：A 是 B 的硬链接（A 和 B 都是文件名），则 A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号相同，即一个 inode 节点对应两个不同的文件名，两个文件名指向同一个文件，A 和 B 对文件系统来说是完全平等的。删除其中任何一个都不会影响另外一个的访问。</p><p>硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的连接。只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。也就是说，文件真正删除的条件是与之相关的所有硬连接文件均被删除。</p><p>软连接</p><p>另外一种连接称之为符号连接（Symbolic Link），也叫软连接。软链接文件有类似于 Windows 的快捷方式。它实际上是一个特殊的文件。在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。比如：A 是 B 的软链接（A 和 B 都是文件名），A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号不相同，A 和 B 指向的是两个不同的 inode，继而指向两块不同的数据块。但是 A 的数据块中存放的只是 B 的路径名（可以根据这个找到 B 的目录项）。A 和 B 之间是“主从”关系，如果 B 被删除了，A 仍然存在（因为两个是不同的文件），但指向的是一个无效的链接。</p><p>测试：</p><pre><code>[root@kuangshen /]# cd /home[root@kuangshen home]# touch f1 # 创建一个测试文件f1[root@kuangshen home]# lsf1[root@kuangshen home]# ln f1 f2     # 创建f1的一个硬连接文件f2[root@kuangshen home]# ln -s f1 f3   # 创建f1的一个符号连接文件f3[root@kuangshen home]# ls -li       # -i参数显示文件的inode节点信息397247 -rw-r--r-- 2 root root     0 Mar 13 00:50 f1397247 -rw-r--r-- 2 root root     0 Mar 13 00:50 f2397248 lrwxrwxrwx 1 root root     2 Mar 13 00:50 f3 -&gt; f1</code></pre><p>从上面的结果中可以看出，硬连接文件 f2 与原文件 f1 的 inode 节点相同，均为 397247，然而符号连接文件的 inode 节点不同。</p><pre><code>#echo 字符串输出 &gt;&gt; f1 输出到 f1文件[root@kuangshen home]# echo "I am f1 file" &gt;&gt;f1[root@kuangshen home]# cat f1I am f1 file[root@kuangshen home]# cat f2I am f1 file[root@kuangshen home]# cat f3I am f1 file[root@kuangshen home]# rm -f f1[root@kuangshen home]# cat f2I am f1 file[root@kuangshen home]# cat f3cat: f3: No such file or directory</code></pre><p>通过上面的测试可以看出：当删除原始文件 f1 后，硬连接 f2 不受影响，但是符号连接 f1 文件无效；</p><p>依此您可以做一些相关的测试，可以得到以下全部结论：</p><p>删除符号连接f3,对f1,f2无影响；</p><p>删除硬连接f2，对f1,f3也无影响；</p><p>删除原文件f1，对硬连接f2没有影响，导致符号连接f3失效；</p><p>同时删除原文件f1,硬连接f2，整个文件会真正的被删除。</p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 指令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>renren-generator逆向工程学习</title>
      <link href="/2021/10/22/renren-generator-ni-xiang-gong-cheng-xue-xi/"/>
      <url>/2021/10/22/renren-generator-ni-xiang-gong-cheng-xue-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="源码地址"><a href="#源码地址" class="headerlink" title="源码地址"></a>源码地址</h1><p><a href="https://gitee.com/renrenio/renren-generator">renren-generator</a><br>本地部署</p><ul><li>通过git下载源码</li><li>修改application.yml，更新MySQL账号和密码、数据库名称</li><li>Eclipse、IDEA运行RenrenApplication.java，则可启动项目</li><li>项目访问路径：<a href="http://localhost/">http://localhost</a><h1 id="修改源码里的application数据库地址"><a href="#修改源码里的application数据库地址" class="headerlink" title="修改源码里的application数据库地址"></a>修改源码里的application数据库地址</h1></li></ul><pre><code>spring:  datasource:    type: com.alibaba.druid.pool.DruidDataSource    #MySQL配置    driverClassName: com.mysql.jdbc.Driver    url: jdbc:mysql://101.35.103.140/gulimall_oms?useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=false    username: root    password: root</code></pre><h1 id="修改源码里的generator-properties文件"><a href="#修改源码里的generator-properties文件" class="headerlink" title="修改源码里的generator.properties文件"></a>修改源码里的generator.properties文件</h1><pre><code>#项目工程名mainPath=com.atguigu#项目包名package=com.atguigu.gulimall#模块名moduleName=order#\u4F5C\u8005#作者author=ggc#Emailemail=ggc#\u8868\u524D\u7F00(\u7C7B\u540D\u4E0D\u4F1A\u5305\u542B\u8868\u524D\u7F00)#数据库表前缀tablePrefix=oms_</code></pre>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 逆向工程 </tag>
            
            <tag> 开发工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis学习笔记</title>
      <link href="/2021/10/22/redis-xue-xi-bi-ji/"/>
      <url>/2021/10/22/redis-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="1-为什么要用Nosql"><a href="#1-为什么要用Nosql" class="headerlink" title="1.为什么要用Nosql"></a>1.为什么要用Nosql</h1><h2 id="1-1用户的个人信息，社交网络，地理位置。用户自己产生的数据，用户日志等等爆发式增长！"><a href="#1-1用户的个人信息，社交网络，地理位置。用户自己产生的数据，用户日志等等爆发式增长！" class="headerlink" title="1.1用户的个人信息，社交网络，地理位置。用户自己产生的数据，用户日志等等爆发式增长！"></a>1.1用户的个人信息，社交网络，地理位置。用户自己产生的数据，用户日志等等爆发式增长！</h2><h2 id="1-2-什么是NoSql"><a href="#1-2-什么是NoSql" class="headerlink" title="1.2 什么是NoSql"></a>1.2 什么是NoSql</h2><h3 id="Not-Only-Sql-不仅仅是sql"><a href="#Not-Only-Sql-不仅仅是sql" class="headerlink" title="Not Only Sql 不仅仅是sql"></a>Not Only Sql 不仅仅是sql</h3><blockquote><p>NoSQL仅仅是一个概念，泛指非关系型的数据库，区别于关系数据库，它们不保证关系数据的ACID特性。NoSQL是一项全新的数据库革命性运动，其拥护者们提倡运用非关系型的数据存储，相对于铺天盖地的关系型数据库运用，这一概念无疑是一种全新的思维的注入解耦</p></blockquote><p>1.方便扩展（数据之间没有关系，很好扩展）<br>2.大数据量高性能（Redis一秒写8万次，读11万，NoSQL的缓存记录级，是一种细粒度的缓存，性能会比较高）<br>3.数据类型是多样型的！（不需要事先设计数据库！随取随用！如果是数据量十分大的表，很多人就无法设计了）<br>4.传统的RDBMS和NoSQL</p><ul><li>传统的RDBMS<ul><li>机构化组织</li><li>SQL</li><li>数据克关系都存在单独的表中 row col</li><li>数据定义语言</li><li>基础的事务</li></ul></li><li>NoSQL<ul><li>不仅仅是数据</li><li>没有固定的查询语言</li><li>键值对存储，列存储，文档存储，图形数据库（社交关系）</li><li>最终一致性</li><li>CAP定理和BASE（异地多活）</li><li>高性能，高可用，高可拓</li></ul></li></ul><p>了解：3V+3高大数据时代的3V：主要是描述问题的<br>海量Volume<br>多样Variety<br>实时Velocity</p><p>大数据时代的3高：主要是对程序的要求<br>高并发<br>高可拓<br>高性能</p><h3 id="1-3、NoSQL的四大分类"><a href="#1-3、NoSQL的四大分类" class="headerlink" title="1.3、NoSQL的四大分类"></a>1.3、NoSQL的四大分类</h3><p>KV键值对：</p><ul><li>新浪：Redis</li><li>美团：Redis + Tair</li><li>阿里、百度：Redis + memecache</li><li>文档型数据库（bson格式和json一样）：</li></ul><ul><li>MongoDB<ul><li>MongoDB是一个基于分布式文件存储的数据库，C++编写，主要用来处理大量的文档！</li><li>MongoDB是一个介于关系型数据库和非关系型数据中间的产品，MongoDB是非关系型数据库中功能最丰富，最像关系型数据库的</li><li>ConthDB</li><li>列存储数据库</li></ul></li></ul><ul><li>HBsae</li><li>分布式文件系统</li><li>图关系数据库</li><li>他不是存图形，放的是关系，比如：朋友圈社交网络，广告推荐</li><li>Neo4j，InfoGrid<br><img src="https://edu-2539.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87/20210322211739805.png" alt="image"></li></ul><h1 id="2-Redis-入门"><a href="#2-Redis-入门" class="headerlink" title="2.Redis 入门"></a>2.Redis 入门</h1><h2 id="2-1-概念"><a href="#2-1-概念" class="headerlink" title="2.1 概念"></a>2.1 概念</h2><blockquote><p>redis 是什么</p></blockquote><p>Redis（Remote Dictionary Server )，即远程字典服务，是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API<br>redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。</p><blockquote><p>redis 能干嘛</p></blockquote><p>1、内存存储、持久化，内存断电即失，持久化很重要（rdb，aof）<br>2、效率高，可以用于告诉缓存<br>3、发布订阅系统<br>4、地图信息分析<br>5、计时器、计数器（浏览量）<br>6…</p><blockquote><p>特性</p></blockquote><p>1、多样的数据类型<br>2、持久化<br>3、集群<br>4、事务<br>…</p><p>官网：<a href="https://redis.io/">https://redis.io/</a><br>中文网：<a href="http://www.redis.cn/">http://www.redis.cn/</a></p><h2 id="2-2-基本环境搭建"><a href="#2-2-基本环境搭建" class="headerlink" title="2.2 基本环境搭建"></a>2.2 基本环境搭建</h2><p>1.下载linux安装包，本文下载的为5.0.12（6.0以上的需要升级gcc，太费劲）<br>2.将redis-5.0.12.tar.gz，传输到opt目录（当然了，不喜欢opt目录其它目录也可以）<br>3.解压 tar -zxvf redis-5.0.12.tar.gz</p><pre><code>tar -zxvf redis-5.0.12.tar.gz</code></pre><p>4.安装gcc</p><pre><code>yum -y install gcc gcc-c++yum install gcc-c++ tcl</code></pre><p>5.进入到redis解压下的目录，执行make</p><pre><code>cd /opt/redis-5.0.12make</code></pre><ol start="6"><li>进入到redis默认安装路径：/usr/local/bin下，查看是否安装完成<br><img src="https://edu-2539.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87/20210323200949703.png" alt="image"></li><li>创建文件夹，用来保存redis的配置文件，并将解压包内的redis.conf，拷贝一份，后续按照拷贝后的文件进行启动</li></ol><pre><code>mkdir /usr/local/bin/redisconfigcp cp /opt/redis-5.0.12/redis.conf /usr/local/bin/redisconfig/</code></pre><ol start="8"><li><p>更改配置文件，配置后台启动<br><img src="https://edu-2539.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87/20210323201349704.png" alt="image"></p></li><li><p>用拷贝过来的配置文件启动redis</p></li></ol><pre><code>redis-server redisconfig/redis.conf</code></pre><ol start="10"><li>客户端连接</li></ol><pre><code>redis-cli -p 6379</code></pre><ol start="11"><li>查看redis进程</li></ol><pre><code>ps -ef|grep redis</code></pre><ol start="12"><li>关闭redis</li></ol><pre><code>shutdownexit</code></pre><h2 id="2-3-性能测试"><a href="#2-3-性能测试" class="headerlink" title="2.3 性能测试"></a>2.3 性能测试</h2><p>Redis性能压测工具 redis-benchmark<br><img src="https://edu-2539.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87/20210323202832713.png" alt="image"></p><h2 id="2-4、redis基础知识"><a href="#2-4、redis基础知识" class="headerlink" title="2.4、redis基础知识"></a>2.4、redis基础知识</h2><p>redis默认有16个数据库，默认使用第0个</p><blockquote><p>Redis是单线程的！<br>Redis是很快的，官方表示，Redis是基于内存操作，CPU不是Redis性能瓶颈，Redis的瓶颈是根据机器的内存和网络带宽，既然可以用单线程来实现，就使用单线程了<br>Redis是C语言写的，官方提供的数据为100000+的QPS，完全不必同样是使用key-value的Memecache差！</p></blockquote><p>Redis为什么是单线程还这么快？</p><blockquote><p>误区1：高性能的服务器一定是多线程的？<br>误区2：多线程（CPU上下文会切换！）一定比单线程效率高？</p></blockquote><p>核心：&nbsp;redis是将所有的数据全部存放在内存中的，所以说使用单线程去操作效率就是最高的，多线程（CPU会上下文切换：耗时操作！）<br>对于内存系统来说，如果没有上下文切换，<br>效率就是最高的，多次读写都是在一个cpu上的，在内存情况下，这个就是最优的方案！</p><h3 id="2-4-1、redis常用命令"><a href="#2-4-1、redis常用命令" class="headerlink" title="2.4.1、redis常用命令"></a>2.4.1、redis常用命令</h3><pre><code>#1.切换数据库  select indexselect 3#2.数据库大小dbsize#3. 查看所有的keykeys *#4. 清空全部flushall#5. 清空当前库flushdb#6.判断某个key是否存在  EXISTS KEY#7.移某个keymove keyName 数据库index  （move name 1）#8.设置key过期时间EXPIRE keyName seconds#9.查询有效期还剩多久ttl keyName#10.查看key类型type keyName</code></pre><h1 id="3、五大数据类型"><a href="#3、五大数据类型" class="headerlink" title="3、五大数据类型"></a>3、五大数据类型</h1><p>Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构，如 字符串（strings），<br>散列（hashes）， 列表（lists）， 集合（sets）， 有序集合（sorted sets） 与范围查询， bitmaps， hyperloglogs 和 地理空间（geospatial）<br>索引半径查询。 Redis 内置了 复制（replication），LUA脚本（Lua scripting）， LRU驱动事件（LRU eviction），事务（transactions） 和不同级别的<br>磁盘持久化（persistence）， 并通过 Redis哨兵（Sentinel）和自动 分区（Cluster）提供高可用性（high availability）。</p><h2 id="3-1、String"><a href="#3-1、String" class="headerlink" title="3.1、String"></a>3.1、String</h2><pre><code>####################################################################127.0.0.1:6379&gt; APPEND name aa #追加，如果追加的key不存在，则新建(integer) 6127.0.0.1:6379&gt; GET name"yangaa"127.0.0.1:6379&gt; STRLEN name #获取key对应值的长度(integer) 6####################################################################127.0.0.1:6379&gt; set views 0 #初始浏览量为0OK127.0.0.1:6379&gt; get views"0"127.0.0.1:6379&gt; INCR views #自+1(integer) 1127.0.0.1:6379&gt; get views"1"127.0.0.1:6379&gt; DECR views(integer) 0127.0.0.1:6379&gt; get views #自-1"0"127.0.0.1:6379&gt; INCRBY views 10 #自+10(integer) 10127.0.0.1:6379&gt; get views"10"127.0.0.1:6379&gt; DECRBY views 5 #自-5(integer) 5127.0.0.1:6379&gt; get views"5"####################################################################127.0.0.1:6379&gt; set key1 hello,yangOK127.0.0.1:6379&gt; get key1"hello,yang"127.0.0.1:6379&gt; GETRANGE key1 0 3 #截取字符串"hell"127.0.0.1:6379&gt; GETRANGE key1 0 -1 #截取全部"hello,yang"127.0.0.1:6379&gt; set key2 abcdOK127.0.0.1:6379&gt; SETRANGE key2 1 xx &nbsp;#替换 &nbsp; SETRANGE key offset value(integer) 4127.0.0.1:6379&gt; get key2"axxd"##################################################################### setex (set with expire) 设置过期时间# setnx (set if not exist) 不存在才设置（在分布式锁中会常常使用）27.0.0.1:6379&gt; setex key3 30 "hello" &nbsp;#设置过期时间OK127.0.0.1:6379&gt; ttl key3(integer) 24127.0.0.1:6379&gt; setnx mykey "redis" #此时mykey不存在才能设置成功(integer) 1127.0.0.1:6379&gt; keys *1) "key1"2) "mykey"3) "key2"127.0.0.1:6379&gt; ttl key3(integer) -2127.0.0.1:6379&gt; setnx mykey "MongoDB" #此时mykey已存在设置不成功(integer) 0127.0.0.1:6379&gt; get mykey"redis"#####################################################################批量set，批量获取，批量不存在set127.0.0.1:6379&gt; mset k1 v1 k2 v2OK127.0.0.1:6379&gt; mget k1 k21) "v1"2) "v2"127.0.0.1:6379&gt; MSETNX k1 v2 k3 v3(integer) 0127.0.0.1:6379&gt; keys *1) "k2"2) "k1"####################################################################set user:1 {name:zhangsan,age:20} #设置一个user:1 对象mset user:1:name zhangsan user:1:age 20mget user:1:name user:1:age####################################################################getset #先get然后再set127.0.0.1:6379&gt; getset key1 redis #如果不存在则返回nil(nil)127.0.0.1:6379&gt; get key1"redis"127.0.0.1:6379&gt; getset key1 mongodb"redis"127.0.0.1:6379&gt; get key1"mongodb"####################################################################</code></pre><p>String类似的使用场景：value除了是我们的字符串还可以是我们的数字</p><ul><li>计数器</li><li>统计多单位的数量</li><li>粉丝数</li><li>对象缓存存储</li></ul><h2 id="3-2-List"><a href="#3-2-List" class="headerlink" title="3.2 List"></a>3.2 List</h2><pre><code>127.0.0.1:6379&gt; LPUSH list one #将一个值或多个值，插入到列表头部（左）(integer) 1127.0.0.1:6379&gt; LPUSH list two(integer) 2127.0.0.1:6379&gt; LPUSH list three(integer) 3127.0.0.1:6379&gt; LRANGE list 0 -11) "three"2) "two"3) "one"127.0.0.1:6379&gt; LRANGE list 0 11) "three"2) "two"127.0.0.1:6379&gt; RPUSH list four #将一个值或多个值，插入到列表尾部（右）(integer) 4127.0.0.1:6379&gt; LRANGE list 0 -11) "three"2) "two"3) "one"4) "four"####################################################LPOP key 从左侧移除一个值RPOP key 从右侧移除一个值LREM key count value 从key中移除count个value127.0.0.1:6379&gt; LRANGE list 0 -11) "three"2) "two"3) "one"4) "four"127.0.0.1:6379&gt; LPOP list"three"127.0.0.1:6379&gt; LRANGE list 0 -11) "two"2) "one"3) "four"127.0.0.1:6379&gt; RPOP list"four"127.0.0.1:6379&gt; LRANGE list 0 -11) "two"2) "one"####################################################LINDEX 通过下角标求值127.0.0.1:6379&gt; LRANGE list 0 -11) "two"2) "one"127.0.0.1:6379&gt; LINDEX list 0"two"127.0.0.1:6379&gt; LRANGE list 0 -11) "one"2) "one"3) "two"4) "one"127.0.0.1:6379&gt; LREM list 1 one #从list中移除1个one(integer) 1127.0.0.1:6379&gt; LRANGE list 0 -11) "one"2) "two"3) "one"####################################################LLEN 求list长度LTRIM key start end  #截取####################################################RPOPLPUSH source destaintion #移除列表最后一个元素，将它移至目标key中127.0.0.1:6379&gt; RPUSH list "hello1"(integer) 1127.0.0.1:6379&gt; RPUSH list "hello2"(integer) 2127.0.0.1:6379&gt; RPUSH list "hello3"(integer) 3127.0.0.1:6379&gt; RPOPLPUSH list otherlist"hello3"127.0.0.1:6379&gt; LRANGE list 0 -11) "hello1"2) "hello2"127.0.0.1:6379&gt; LRANGE otherlist 0 -11) "hello3"####################################################LSET key index value 将列表中指定下标的值替换127.0.0.1:6379&gt; LRANGE list 0 -11) "hello1"2) "hello2"127.0.0.1:6379&gt; LSET list 0 "aa"OK127.0.0.1:6379&gt; LRANGE list 0 -11) "aa"2) "hello2"####################################################LINSERT key before|after pivot value  #指定字符前后插入值127.0.0.1:6379&gt; lrange list 0 -11) "hello"2) "word"127.0.0.1:6379&gt; LINSERT list before word find(integer) 3127.0.0.1:6379&gt; LRANGE list 0 -11) "hello"2) "find"3) "word"127.0.0.1:6379&gt; LINSERT list after word yeah(integer) 4127.0.0.1:6379&gt; LRANGE list 0 -11) "hello"2) "find"3) "word"4) "yeah"</code></pre><p>小结：list为双向链表，在两边插入或改动值，效率最高！中间元素，相对来说效率会低一点</p><h2 id="3-3-set"><a href="#3-3-set" class="headerlink" title="3.3 set"></a>3.3 set</h2><pre><code>SADD key [member....]  像set中插入值SMEMBERS key 查看key中有哪些值SISMENBER key value  查看key中是否存在这个值127.0.0.1:6379&gt; SADD myset hello fine word(integer) 3127.0.0.1:6379&gt; SMEMBERS myset1) "fine"2) "word"3) "hello"127.0.0.1:6379&gt; SISMEMBER myset hello(integer) 1127.0.0.1:6379&gt; SISMEMBER myset yang(integer) 0#################################################SCARD key 查看set中值的数量SREM key value 移除key中某一个值127.0.0.1:6379&gt; SCARD myset(integer) 3127.0.0.1:6379&gt; SREM myset word(integer) 1#################################################SMOVE key otherkey member  移除指定元素至另一个key中127.0.0.1:6379&gt; SMOVE myset myotnerset hello(integer) 1#################################################SDIFF key1 key2 差集SINTER key1 key2 交集SUNION key1 key2 并集127.0.0.1:6379&gt; SADD key1 a(integer) 1127.0.0.1:6379&gt; SADD key1 b(integer) 1127.0.0.1:6379&gt; SADD key1 c(integer) 1127.0.0.1:6379&gt; SADD key2 c(integer) 1127.0.0.1:6379&gt; SADD key2 d(integer) 1127.0.0.1:6379&gt; SADD key2 e(integer) 1127.0.0.1:6379&gt; SDIFF key1 key21) "a"2) "b"127.0.0.1:6379&gt; SINTER key1 key21) "c"127.0.0.1:6379&gt; SUNION key1 key21) "a"2) "b"3) "c"4) "d"5) "e"</code></pre><h2 id="3-4-Hsah"><a href="#3-4-Hsah" class="headerlink" title="3.4 Hsah"></a>3.4 Hsah</h2><pre><code>HSET key filed value #hash存值HGET key filed #hash取值HMSET key [filed value ...] #批量存HGET key [filed...] #批量取HGETALL key #取全部HDEL key [filed...] #删除某一个或某几个HLEN key #获取长度HEXISTS key value #获取某个值是否存在HKEYS key #获取所有的filedHVALS key #获取所有的value127.0.0.1:6379&gt; HSET myhash name yang (integer) 1127.0.0.1:6379&gt; HGET myhash name"yang"127.0.0.1:6379&gt; HMSET myhash name yang1 age 18OK127.0.0.1:6379&gt; HMGET myhash name age1) "yang1"2) "18"127.0.0.1:6379&gt; HGETALL myhash1) "name"2) "yang1"3) "age"4) "18"127.0.0.1:6379&gt; HDEL myhash name(integer) 1127.0.0.1:6379&gt; HLEN myhash(integer) 1127.0.0.1:6379&gt; HEXISTS myhash age(integer) 1</code></pre><h2 id="3-5-zset（有序集合）"><a href="#3-5-zset（有序集合）" class="headerlink" title="3.5 zset（有序集合）"></a>3.5 zset（有序集合）</h2><pre><code>127.0.0.1:6379&gt; ZADD myset 100 xiaoming(integer) 1127.0.0.1:6379&gt; ZADD myset 200 xiaohong(integer) 1127.0.0.1:6379&gt; ZADD myset 300 xiaowang(integer) 1127.0.0.1:6379&gt; ZRANGEBYSCORE myset -inf +inf  #显示全部的用户，从小到大1) "xiaoming"2) "xiaohong"3) "xiaowang"127.0.0.1:6379&gt; ZRANGEBYSCORE myset -inf +inf withscores #显示全部的用户，从小到大并附带值1) "xiaoming"2) "100"3) "xiaohong"4) "200"5) "xiaowang"6) "300"127.0.0.1:6379&gt; ZREVRANGE myset 0 -1  #显示全部的用户，从大到小1) "xiaowang"2) "xiaohong"3) "xiaoming"127.0.0.1:6379&gt; ZREVRANGE myset 0 -1 withscores1) "xiaowang"2) "300"3) "xiaohong"4) "200"5) "xiaoming"6) "100"127.0.0.1:6379&gt; ZRANGEBYSCORE myset -inf 200 withscores #显示小于等于200全部的用户，从小到大并附带值1) "xiaoming"2) "100"3) "xiaohong"4) "200"</code></pre><h1 id="4-三种特殊数据类型"><a href="#4-三种特殊数据类型" class="headerlink" title="4.三种特殊数据类型"></a>4.三种特殊数据类型</h1><h2 id="4-1geospatial-地理位置"><a href="#4-1geospatial-地理位置" class="headerlink" title="4.1geospatial 地理位置"></a>4.1geospatial 地理位置</h2><p>GEOADD</p><pre><code>#getadd 添加地理位置#规则：两级无法直接添加#有效的经度从-180度到180度#有效的纬度从-85.05112878度到85.05112878GEOADD china:city 116.40 39.90 beijing 121.47 31.23 shanghai</code></pre><p>GEOPOS</p><pre><code>127.0.0.1:6379&gt; GEOPOS china:city beijing #获取城市的经度和纬度1) 1) "116.39999896287918091"   2) "39.90000009167092543"</code></pre><p>GEODIST key member1 member2 [unit]</p><blockquote><p>返回两个给定位置之间的距离。<br>如果两个位置之间的其中一个不存在， 那么命令返回空值。<br>指定单位的参数 unit 必须是以下单位的其中一个：<br>m 表示单位为米。<br>km 表示单位为千米。<br>mi 表示单位为英里。<br>ft 表示单位为英尺。<br>如果用户没有显式地指定单位参数， 那么 GEODIST 默认使用米作为单位。<br>GEODIST 命令在计算距离时会假设地球为完美的球形， 在极限情况下， 这一假设最大会造成 0.5% 的误差。</p></blockquote><pre><code>127.0.0.1:6379&gt; GEODIST china:city beijing shanghai km"1067.3788"</code></pre><p>GEORADIUS</p><blockquote><p>key longitude latitude radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count]<br>以给定的经纬度为中心， 返回键包含的位置元素当中， 与中心的距离不超过给定最大距离的所有位置元素。<br>范围可以使用以下其中一个单位：<br>m 表示单位为米。<br>km 表示单位为千米。<br>mi 表示单位为英里。<br>ft 表示单位为英尺。<br>在给定以下可选项时， 命令会返回额外的信息：<br>WITHDIST: 在返回位置元素的同时， 将位置元素与中心之间的距离也一并返回。 距离的单位和用户给定的范围单位保持一致。<br>WITHCOORD: 将位置元素的经度和维度也一并返回。<br>WITHHASH: 以 52 位有符号整数的形式， 返回位置元素经过原始 geohash 编码的有序集合分值。 这个选项主要用于底层应用或者调试， 实际中的作用并不大。<br>命令默认返回未排序的位置元素。 通过以下两个参数， 用户可以指定被返回位置元素的排序方式：<br>ASC: 根据中心的位置， 按照从近到远的方式返回位置元素。<br>DESC: 根据中心的位置， 按照从远到近的方式返回位置元素。<br>在默认情况下， GEORADIUS 命令会返回所有匹配的位置元素。 虽然用户可以使用 COUNT 选项去获取前 N 个匹配元素， 但是因为命令在内部可能会需要对所有被匹配的元素进行处理， 所以在对一个非常大的区域进行搜索时， 即使只使用 COUNT 选项去获取少量元素， 命令的执行速度也可能会非常慢。 但是从另一方面来说， 使用 COUNT 选项去减少需要返回的元素数量， 对于减少带宽来说仍然是非常有用的。</p></blockquote><pre><code>127.0.0.1:6379&gt; GEORADIUS china:city 110 30 5000 km  #以经纬度为110 30为中心查询5000km的城市1) "shanghai"2) "beijing"127.0.0.1:6379&gt; GEORADIUS china:city 110 30 5000 km withdist #显示到中间距离的位置1) 1) "shanghai"   2) "1105.9098"2) 1) "beijing"   2) "1245.2858"</code></pre><p>GEORADIUSBYMEMBER</p><blockquote><p>key member radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count]<br>这个命令和 GEORADIUS 命令一样， 都可以找出位于指定范围内的元素， 但是 GEORADIUSBYMEMBER 的中心点是由给定的位置元素决定的， 而不是像 GEORADIUS 那样， 使用输入的经度和纬度来决定中心点<br>指定成员的位置被用作查询的中心。</p></blockquote><p>GEOHASH key member [member …]</p><blockquote><p>该命令将返回11个字符的Geohash字符串，所以没有精度Geohash，损失相比，使用内部52位表示。返回的geohashes具有以下特性<br>他们可以缩短从右边的字符。它将失去精度，但仍将指向同一地区。<br>它可以在 geohash.org 网站使用，网址 <a href="http://geohash.org/%E3%80%82%E6%9F%A5%E8%AF%A2%E4%BE%8B%E5%AD%90%EF%BC%9Ahttp://geohash.org/sqdtr74hyu0">http://geohash.org/。查询例子：http://geohash.org/sqdtr74hyu0</a>.<br>与类似的前缀字符串是附近，但相反的是不正确的，这是可能的，用不同的前缀字符串附近。</p></blockquote><blockquote><p>GEO底层的实现原理其实就是Zset！我们可以使用Zset命令操作geo</p></blockquote><pre><code>127.0.0.1:6379&gt; ZRANGE china:city 0 -11) "shanghai"2) "beijing"</code></pre><h2 id="4-2、Hyperloglog"><a href="#4-2、Hyperloglog" class="headerlink" title="4.2、Hyperloglog"></a>4.2、Hyperloglog</h2><blockquote><p>简介<br>Redis2.8.9版本更新了Hyperloglog数据结构<br>Redis Hyperloglog基数统计的算法<br>优点：占用的内存是固定，2^6不同的元素的计数，只需要废12kb内存，如果从内存角度来比较的话Hyperloglog首选<br>网页的UV（一个人访问一个网站多次，但是还是算作一个人）<br>传统的方式，set保存用户的id，然后就可以统计set中的元素数量作为标准判断<br>这个方式如果保存大量的用户id，就会比较麻烦！我们目的是为了计数，而不是保存用户id<br>0.81%错误率！统计UV任务，可以忽略不计。</p></blockquote><pre><code>127.0.0.1:6379&gt; PFADD mykey a b c d e f  #创建第一组元素 mykey(integer) 1127.0.0.1:6379&gt; PFCOUNT mykey #统计mykey中元素的数量(integer) 6127.0.0.1:6379&gt; PFADD mykey1 b c d r j d #创建第二组元素 mykey1(integer) 1127.0.0.1:6379&gt; PFCOUNT mykey1(integer) 5127.0.0.1:6379&gt; PFMERGE mykey2 mykey mykey1 #合并两组mykey mykey1 =&gt; mykey2 并集OK127.0.0.1:6379&gt; PFCOUNT mykey2 #查看并集数量(integer) 8</code></pre><h2 id="4-3、Bitmap"><a href="#4-3、Bitmap" class="headerlink" title="4.3、Bitmap"></a>4.3、Bitmap</h2><blockquote><p>位存储统计用户信息，活跃，不活跃，打卡，未打卡 两个状态的数据，都可以使用BitmapsBitmap位图，数据结构！都是二进制位来进行记录，就只有0和1两个状态</p></blockquote><pre><code>127.0.0.1:6379&gt; setbit sign 0 1  #第1天 打卡了(integer) 0127.0.0.1:6379&gt; setbit sign 1 1 #第2天 打卡了(integer) 0 127.0.0.1:6379&gt; setbit sign 2 0 #第3天 没打卡(integer) 0127.0.0.1:6379&gt; setbit sign 3 0(integer) 0127.0.0.1:6379&gt; setbit sign 4 1(integer) 0127.0.0.1:6379&gt; getbit sign 0  #获取某一天是否打卡(integer) 1127.0.0.1:6379&gt; BITCOUNT sign 0 4  #第一天到第五天共计打卡几次(integer) 3</code></pre><h1 id="5-事务"><a href="#5-事务" class="headerlink" title="5.事务"></a>5.事务</h1><p>Redis事务本质：一组命令的集合！一个事务中的所有命令都会被序列化，在事务执行过程中，会按照顺序执行！一次性、顺序性、排他性！执行一系列的命令<br><code>-----------------队列 set set set 执行 </code></p><p>Redis事务没有隔离级别的概念！<br>所有的命令在事务中，并没有被直接执行！只有发起执行命令的时候才会执行！Exec<br>Redis单条命令是保持原子性的，但是事务不保证原子性！</p><p>Redis的事务：</p><ul><li>开启事务（multi）</li><li>命令入队（…）</li><li>执行事务（）</li></ul><blockquote><p>正常执行事务</p></blockquote><pre><code>127.0.0.1:6379&gt; MULTI  #开启事务OK127.0.0.1:6379&gt; set k1 v1  #命令入队QUEUED127.0.0.1:6379&gt; set k2 v2QUEUED127.0.0.1:6379&gt; set k3 v3QUEUED127.0.0.1:6379&gt; EXEC #执行事务1) OK2) OK3) OK127.0.0.1:6379&gt;</code></pre><blockquote><p>放弃事务</p></blockquote><pre><code>127.0.0.1:6379&gt; MULTIOK127.0.0.1:6379&gt; set k1 v1QUEUED127.0.0.1:6379&gt; set k4 v4QUEUED127.0.0.1:6379&gt; DISCARD  #放弃事务OK</code></pre><blockquote><p>编译型异常（代码有问题！命令有错），事务中所有的命令都不会被执行</p></blockquote><pre><code>127.0.0.1:6379&gt; MULTIOK127.0.0.1:6379&gt; set k1 v1QUEUED127.0.0.1:6379&gt; set k2 v2QUEUED127.0.0.1:6379&gt; getset k3  #错误的命令(error) ERR wrong number of arguments for 'getset' command127.0.0.1:6379&gt; set k4 v4QUEUED127.0.0.1:6379&gt; EXEC(error) EXECABORT Transaction discarded because of previous errors.127.0.0.1:6379&gt; get k1  #所有的命令都不会被执行(nil)</code></pre><blockquote><p>运行时异常（1/0），如果事务队列中存在语法性，那么执行命令的时候，其他命令是可以正常执行的，错误命令抛出异常</p></blockquote><pre><code>127.0.0.1:6379&gt; set k1 v1OK127.0.0.1:6379&gt; MULTIOK127.0.0.1:6379&gt; INCR k1 #会执行失败QUEUED127.0.0.1:6379&gt; set k2 v2QUEUED127.0.0.1:6379&gt; exec1) (error) ERR value is not an integer or out of range  #后续的命令可以正常执行2) OK</code></pre><blockquote><p>监控 Watch</p></blockquote><p>悲观锁很悲观，</p><ul><li>什么时候都会出问题，无论做什么都会加锁</li></ul><p>乐观锁</p><ul><li>很乐观，认为什么时候都不会出问题，所以不会上锁！更新数据的时候判断一下，在此期间是否有人修改过这个数据</li><li>获取version</li><li>更新的时候比较version</li></ul><blockquote><p>Redis监视测试</p></blockquote><p>正常执行成功</p><pre><code>127.0.0.1:6379&gt; set k1 v1OK127.0.0.1:6379&gt; MULTIOK127.0.0.1:6379&gt; INCR k1QUEUED127.0.0.1:6379&gt; set k2 v2QUEUED127.0.0.1:6379&gt; exec1) (error) ERR value is not an integer or out of range2) OK</code></pre><p>测试多线程修改值，使用watch可以当作redis的乐观锁操作<br><img src="https://edu-2539.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87/20210327152307821.png" alt="image"><br><img src="https://edu-2539.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87/20210327152413256.png" alt="image"><br>解除监控，unwatch<br><img src="https://edu-2539.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87/20210327152933111.png" alt="image"></p><h1 id="6、jedis"><a href="#6、jedis" class="headerlink" title="6、jedis"></a>6、jedis</h1><blockquote><p>什么是jedis</p></blockquote><p>jedis是Redis官方推荐的java连接开发工具！使用java操作redis中间件！</p><blockquote><p>测试</p></blockquote><p>1.导入对应的依赖</p><pre><code>&lt;!--导入jedis包--&gt;        &lt;!-- https://mvnrepository.com/artifact/redis.clients/jedis --&gt;        &lt;dependency&gt;            &lt;groupId&gt;redis.clients&lt;/groupId&gt;            &lt;artifactId&gt;jedis&lt;/artifactId&gt;            &lt;version&gt;3.2.0&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;            &lt;artifactId&gt;fastjson&lt;/artifactId&gt;            &lt;version&gt;1.2.62&lt;/version&gt;        &lt;/dependency&gt;</code></pre><p>2.编码测试</p><blockquote><p>如果需要连接远程redis服务，不连接本地redis服务<br>一：修改配置文件 redis.conf<br>1.注掉bing 127.0.0.1<br>2.设置访问redis的密码 requirepass 密码<br>3.重启redis服务<br>4.使用密码登录 redis-cli redis配置文件 -h 127.0.0.1 -p 6379 -a 密码<br>二：关掉防火墙：systemctl stop firewalld<br>#注意防火墙每次重启服务器都会自动开放，为了安全不建议移除自启动，移除防火墙自启动systemctl disable firewalld<br>或者可以开放防火墙端口：<br>firewall-cmd –permanent –add-port=6379/tcp<br>firewall-cmd –reload<br>三：idea连接时增加<br>jedis.auth(“123”);//123为配置文件中设置的密码</p></blockquote><pre><code>public class TestPing {    public static void main(String[] args) {        Jedis jedis = new Jedis("192.168.1.101", 6379);        jedis.auth("123");        System.out.println(jedis.ping());    }}</code></pre><h1 id="7、SpringBoot整合"><a href="#7、SpringBoot整合" class="headerlink" title="7、SpringBoot整合"></a>7、SpringBoot整合</h1><p>SpringBoot操作数据：spring-data jpa jdbc mongodb redis!SpringData 也是和SpringBoot齐名的项目说明：在SpringBoot2.x之后，原来使用的jedis被替换为了lettuce</p><blockquote><p>为什么将jedis替换为lettuce？<br>jedis：采用的直连，多个线程操作的话，是不安全的，如果想要避免不安全的，使用jedis pool连接池！更像BIO模式<br>lettuce：采用netty，实例可以在多个线程中进行共享，不存在线程不安全的情况！可以减少线程数据了，更像NIO模式</p></blockquote><p>源码分析：</p><pre><code>@Configuration(proxyBeanMethods = false)@ConditionalOnClass(RedisOperations.class)@EnableConfigurationProperties(RedisProperties.class)@Import({ LettuceConnectionConfiguration.class, JedisConnectionConfiguration.class })public class RedisAutoConfiguration {    @Bean    @ConditionalOnMissingBean(name = "redisTemplate")//我们可以自己定义一个    @ConditionalOnSingleCandidate(RedisConnectionFactory.class)    public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) {        //默认的RedisTemplate没有过多的设置，redis对象都是需要序列化的        //两个泛型都是Object，Object的类型，我们使用后需要强制转换&lt;String,Object&gt;        RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate&lt;&gt;();        template.setConnectionFactory(redisConnectionFactory);        return template;    }    @Bean    @ConditionalOnMissingBean    @ConditionalOnSingleCandidate(RedisConnectionFactory.class)    public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory redisConnectionFactory) {        StringRedisTemplate template = new StringRedisTemplate();        template.setConnectionFactory(redisConnectionFactory);        return template;    }}</code></pre><p>1、导入依赖</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>2、配置连接</p><pre><code>spring:  redis:    host: 192.168.1.101    port: 6379    password: 123</code></pre><p>3.测试</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@SpringBootTest</span><span class="token keyword">class</span> <span class="token class-name">RedisSpringStudyApplicationTests</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> RedisTemplate redisTemplate<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">void</span> <span class="token function">contextLoads</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//redisTemplate  操作不同的数据类型，api和命令是一样的</span>        <span class="token comment" spellcheck="true">//opsForValue 操作字符串 类似String</span>        <span class="token comment" spellcheck="true">//opsForList()</span>        <span class="token comment" spellcheck="true">//opsForSet()</span>        <span class="token comment" spellcheck="true">//opsForZSet()</span>        <span class="token comment" spellcheck="true">//opsForHash()</span>        <span class="token comment" spellcheck="true">//opsForGeo()</span>        <span class="token comment" spellcheck="true">//opsForHyperLogLog()</span>        <span class="token comment" spellcheck="true">//除了基本的操作，我们常用的方法都可以直接通过redisTemplate操作，比如事务，和基本的CRUD</span>        <span class="token comment" spellcheck="true">//获取连接对象</span>        <span class="token comment" spellcheck="true">//RedisConnection connection = redisTemplate.getConnectionFactory().getConnection();</span>        <span class="token comment" spellcheck="true">//connection.flushAll();</span>        <span class="token comment" spellcheck="true">//connection.flushDb();</span>        redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"myKey"</span><span class="token punctuation">,</span> <span class="token string">"hello redis"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"myKey"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><em>不序列化会报异常</em></p><h2 id="7-1、自定义RedisTemplate"><a href="#7-1、自定义RedisTemplate" class="headerlink" title="7.1、自定义RedisTemplate"></a>7.1、自定义RedisTemplate</h2><pre><code>import com.fasterxml.jackson.annotation.JsonAutoDetect;import com.fasterxml.jackson.annotation.PropertyAccessor;import com.fasterxml.jackson.databind.ObjectMapper;import com.fasterxml.jackson.databind.jsontype.impl.LaissezFaireSubTypeValidator;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.data.redis.connection.RedisConnectionFactory;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;import org.springframework.data.redis.serializer.StringRedisSerializer;@Configurationpublic class RedisConfig {    @Bean    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) {        RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;String, Object&gt;();        template.setConnectionFactory(redisConnectionFactory);        //Json序列化配置        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer&lt;&gt;(Object.class);        ObjectMapper om = new ObjectMapper();        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);        om.activateDefaultTyping(LaissezFaireSubTypeValidator.instance, ObjectMapper.DefaultTyping.NON_FINAL);        jackson2JsonRedisSerializer.setObjectMapper(om);        //String 的序列化        StringRedisSerializer stringRedisSerializer = new StringRedisSerializer();        //key采用String的序列化方式        template.setKeySerializer(stringRedisSerializer);        //hash的key采用String的序列化方式        template.setHashKeySerializer(stringRedisSerializer);        //value序列化方式采用jackson        template.setValueSerializer(jackson2JsonRedisSerializer);        //hash的value序列化方式采用jackson        template.setHashValueSerializer(jackson2JsonRedisSerializer);        template.afterPropertiesSet();        return template;    }}</code></pre><p>这样只要在实体中实现序列化，就不会有乱码问题了</p><pre><code>import java.io.Serializable;@Component@NoArgsConstructor@AllArgsConstructor@Datapublic class User implements Serializable {    private static final long serialVersionUID = 1L;    private String name;    private int age;}</code></pre><h2 id="7-1、自定义Redis工具类网上好多："><a href="#7-1、自定义Redis工具类网上好多：" class="headerlink" title="7.1、自定义Redis工具类网上好多："></a>7.1、自定义Redis工具类网上好多：</h2><p><a href="https://blog.csdn.net/ye17186/article/details/87934399">redis工具类</a><br><a href="https://blog.csdn.net/qq_40925189/article/details/109585667">redis工具类</a></p><h1 id="8、Redis-conf详解"><a href="#8、Redis-conf详解" class="headerlink" title="8、Redis.conf详解"></a>8、Redis.conf详解</h1><h1 id="9、Redis"><a href="#9、Redis" class="headerlink" title="9、Redis"></a>9、Redis</h1><p>持久化RDB于AOF详情请见：<br><a href="https://blog.csdn.net/weixin_45416687/article/details/115283376">https://blog.csdn.net/weixin_45416687/article/details/115283376</a></p><h1 id="10、Redis发布订阅"><a href="#10、Redis发布订阅" class="headerlink" title="10、Redis发布订阅"></a>10、Redis发布订阅</h1><p>Redis发布订阅（pub/sub）是一种消息通信模式：发送者（pub）发送消息，订阅者（sub）接收消息。Redis客户端可以订阅任意数量的频道<br>订阅/发布消息图：<br><img src="https://edu-2539.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87/20210328181022397.png" alt="image"></p><p>下图展示了频道channel1，以及订阅这个频道的三个客户端–client2、client5和client1之间的关系：</p><p><img src="https://edu-2539.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87/20210328181658616.png" alt="image"></p><p>当有新消息通过PUBLISH命令发送给频道channel1时，这个消息就会被发送给订阅它的三个客户端：<br><img src="https://edu-2539.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87/20210328181708956.png" alt="image"></p><blockquote><p>命令</p></blockquote><p>这些命令被广泛用于构建即时通信应用，比如网络聊天室（chatroom）和实时广播、实时提醒等<br><img src="https://edu-2539.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87/20210328181735528.png" alt="image"></p><p>实例<br>以下实例演示了发布订阅是如何工作的，需要开启两个 redis-cli 客户端。<br>在我们实例中我们创建了订阅频道名为 runoobChat:</p><blockquote><p>第一个客户端<br>redis 127.0.0.1:6379&gt; SUBSCRIBE runoobChat<br>Reading messages… (press Ctrl-C to quit)“subscribe”“redisChat”(integer) 1</p></blockquote><p>现在，我们先重新开启个 redis 客户端，然后在同一个频道 runoobChat 发布两次消息，订阅者就能接收到消息。</p><blockquote><p>第二个客户端：<br>redis 127.0.0.1:6379&gt; PUBLISH runoobChat “Redis PUBLISH test”<br>(integer) 1<br>redis 127.0.0.1:6379&gt; PUBLISH runoobChat “Learn redis by runoob.com”<br>(integer) 1<br>订阅者的客户端会显示如下消息<br>“message”<br>“runoobChat”<br>“Redis PUBLISH test”<br>“message”<br>“runoobChat”<br>“Learn redis by runoob.com”</p></blockquote><blockquote><p>原理<br>Redis是使用C实现的，通过分析Redis源码里的pubsub.c文件，了解发布和订阅机制的底层实现，借此加深对Redis的理解。<br>Redis通过PUBLISH、SUBSCRIBE等命令实现发布和订阅功能</p></blockquote><p>通过SUBSCRIBE命令订阅某个频道后，redis-server里维护了一个字典，字典的键就是一个个频道！而字典的值则是一个链表，链表中保存了所有订阅这个channel的客户端。SUBSCRIBE命令的关键，就是将客户端添加到指定channel的订阅链表中<br>通过PUBLISH命令向订阅者发送消息，redis-server会使用给定的频道作为键，在它所维护的channel字典中查找记录了订阅这个频道的所有客户端的链表，遍历这个链表，将消息发布给所有订阅者</p><h1 id="11、Redis主从复制"><a href="#11、Redis主从复制" class="headerlink" title="11、Redis主从复制"></a>11、Redis主从复制</h1><h2 id="11-1-概念"><a href="#11-1-概念" class="headerlink" title="11.1 概念"></a>11.1 概念</h2><p> 主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点（master/leader），后者称为从节点（slave/follower）；数据的复制是单向的，只能由主节点到从节点。Master以写为主，Slave以读为主。</p><p>默认情况下，每台Redis服务器都是主节点；且一个主节点可以有多个从节点（或没有从节点），但一个从节点只能有一个主节点。</p><blockquote><p>主从复制的作用主要包括：</p></blockquote><p>1、数据冗余：主从复制实现了数据的热备份，是持久化的一种数据冗余方式<br>2、故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余<br>3、负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量<br>4、高可用基石：除了上述作用外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础</p><hr><p>一般来说，要将Redis运用于工程项目中，只是用一台Redis是万万不能的，原因如下：<br>1、从结构上，单个Redis服务器会发生单点故障，并且一台服务器需要处理所有的请求负载，压力较大；<br>2、从容量上，单个Redis服务器内存容量优先，就算一台Redis服务器内存容量为256G，也不能将所有内存用作Redis存储内存，一般来说，单台Redis最大使用内存不应该超过20G<br><img src="https://edu-2539.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87/20210328193609365.png" alt="image"></p><p>环境配置，搭建伪集群</p><blockquote><p>修改配置文件<br>port：进程占用的端口号<br>pid（port id）：记录了进程的id，文件带有锁，可以防止程序的多次启动<br>logfile：明确日志文件位置<br>dbfilename：dumpxxx.file 持久化文件位置<br>如果设置了密码，需要在从机上添加masterauth 主机密码，否则从机连接不上主机<br><img src="https://edu-2539.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87/20210328195717981.png" alt="image"></p></blockquote><h2 id="11-2、主从复制之复制原理"><a href="#11-2、主从复制之复制原理" class="headerlink" title="11.2、主从复制之复制原理"></a>11.2、主从复制之复制原理</h2><p>默认情况下，每台Redis服务器都是主节点<br>查看命令：INFO replication<br><img src="https://edu-2539.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87/20210328200125258.png" alt="image"></p><p>一主二从<br>配置从机，认老大，一主（79）二从（80、81）<br>1.通过命令配置</p><pre><code>192.168.137.140:6380&gt; SLAVEOF 192.168.137.140 6379  #配置从机  SLAVEOF host portOK192.168.137.140:6380&gt; info replication #查看# Replicationrole:slave #当前角色master_host:192.168.137.140  #查看主机的配置master_port:6379master_link_status:downmaster_last_io_seconds_ago:-1master_sync_in_progress:0slave_repl_offset:1master_link_down_since_seconds:1616933195slave_priority:100slave_read_only:1connected_slaves:0master_replid:60515091a402e7416c97cf7fc9d95b212f3b38a2master_replid2:0000000000000000000000000000000000000000master_repl_offset:0second_repl_offset:-1repl_backlog_active:0repl_backlog_size:1048576repl_backlog_first_byte_offset:0repl_backlog_histlen:0################################################配置完成后，也可以在主机上查看从机配置192.168.137.140:6379&gt; info replication# Replicationrole:masterconnected_slaves:2 #已经连接两个从节点slave0:ip=192.168.137.140,port=6380,state=online,offset=84,lag=0slave1:ip=192.168.137.140,port=6381,state=online,offset=84,lag=0master_replid:3d553be66e2a6e5c19dbeb104fb224a3e093517dmaster_replid2:0000000000000000000000000000000000000000master_repl_offset:84second_repl_offset:-1repl_backlog_active:1repl_backlog_size:1048576repl_backlog_first_byte_offset:1repl_backlog_histlen:84</code></pre><p>2.通过修改配置文件配置<br><img src="https://edu-2539.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87/2021032820241324.png" alt="image"></p><blockquote><p>细节</p></blockquote><p>主机可以写，从机不能写只能读！主机中的所有信息和数据，都会在从机自动保存<br>主机写：<br><img src="https://edu-2539.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87/20210328202810617.png" alt="image"><br>从机只能读取内容<br><img src="https://edu-2539.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87/20210328202858157.png" alt="image"></p><ul><li>主机断开连接，从机依旧连接主机，但是没有写的操作</li><li>从机断开后，重新连接后，成为从机后，依旧会获取到断开时的主机数据<blockquote><p>复制原理<br>Slave启动成功连接到master后会发送一个sync同步命令<br>Master接到命令后，启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕后，master将传送整个数据文件到slave，并完成一次完全同步</p></blockquote></li><li>*<u><em>全量复制</em></u>**：slave服务在接收到数据库文件数据后，将其存盘并加载到内存中</li><li>*<u><em>增量复制</em></u>**：Master继续将新的所有收集到的修改命令一次传给slave，完成同步<br>但是只要是重新来凝结master，一次完全同步（全量复制）将被自动执行</li></ul><blockquote><p>层层链路</p></blockquote><p>上一个M连接下一个S！<br><img src="https://edu-2539.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87/20210328204305760.png" alt="image"></p><blockquote><p>如果没有老大了，这个时候能不能选择一个老大出来？手动</p></blockquote><p>如果主机79断开了链接，我们可以使用slaveof no one让80自己变成主节点，如果这个时候主机79恢复了，也不会改变谋朝篡位成功的80</p><h1 id="12、哨兵模式-（自动选老大）"><a href="#12、哨兵模式-（自动选老大）" class="headerlink" title="12、哨兵模式 （自动选老大）"></a>12、哨兵模式 （自动选老大）</h1><h2 id="12-1概述"><a href="#12-1概述" class="headerlink" title="12.1概述"></a>12.1概述</h2><p>主从切换计数的方法是：当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费时费力，还会造成一段时间内服务不可用。这不是一种推荐的方式，更多时候，我们优先考虑哨兵模式。Redis从2.8开始正式提供了Sentinel（哨兵）架构来解决这个问题</p><p>谋朝篡位的自动版，能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库</p><p>哨兵模式是一种特殊的模式，首先Redis提供了哨兵的命令，哨兵是一个独立的进程，作为进程，它会独立运行。其原理是哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例<br><img src="https://edu-2539.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87/20210328210041629.png" alt="image"><br>这里的哨兵有两个作用</p><ul><li>通过发送命令，让Redis服务器的返回监控其运行状态，包括主服务器和从服务器</li><li>当哨兵监测到master宕机，会自动将slave切换程master，然后通过发布订阅模式通知其他的从服务器，修改配置文件，让它么切换主机</li></ul><p>然而一个哨兵进行对Redis服务器进行监控，可能会出现问题，为此，我们可以使用多个哨兵进行监控。各个哨兵之间还会进行监控，这样就形成了多哨兵模式</p><p><img src="https://edu-2539.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87/2021032821051280.png" alt="image"><br>假设主服务器宕机，哨兵1先检测到这个结果，系统并不会马上进行failover过程，仅仅是哨兵1主观的认为主服务器不可用，这个现象称为主观下线 当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行failover【故障转移】操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为客观下线</p><blockquote><p>测试</p></blockquote><p>我们目前的状态是一主二从<br>1、配置哨兵配置文件 sentinel.conf</p><pre><code>vim sentinel.conf# sentinel monitor 被监控的主机名称 host port 1sentinel monitor myredis 192.168.137.140 6379 1#后面这个数字1，代表主机挂了，slave投票让谁接替成为主机，票数最多的，就会成为主机#有密码的需要在配置文件中增加sentinel auth-pass &lt;master-name&gt; &lt;password&gt;</code></pre><p><img src="https://edu-2539.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87/2021032821275945.png" alt="image"></p><p>2、启动哨兵</p><pre><code># redis-sentinel sentinel的配置文件[root@localhost bin]# redis-sentinel redisconfig/sentinel.conf 20858:X 28 Mar 2021 21:28:22.566 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo20858:X 28 Mar 2021 21:28:22.566 # Redis version=5.0.12, bits=64, commit=00000000, modified=0, pid=20858, just started20858:X 28 Mar 2021 21:28:22.566 # Configuration loaded20858:X 28 Mar 2021 21:28:22.567 * Increased maximum number of open files to 10032 (it was originally set to 1024).                _._                                                             _.-``__ ''-._                                                   _.-``    `.  `_.  ''-._           Redis 5.0.12 (00000000/0) 64 bit  .-`` .-```.  ```\/    _.,_ ''-._                                    (    '      ,       .-`  | `,    )     Running in sentinel mode |`-._`-...-` __...-.``-._|'` _.-'|     Port: 26379 |    `-._   `._    /     _.-'    |     PID: 20858  `-._    `-._  `-./  _.-'    _.-'                                    |`-._`-._    `-.__.-'    _.-'_.-'|                                   |    `-._`-._        _.-'_.-'    |           http://redis.io          `-._    `-._`-.__.-'_.-'    _.-'                                    |`-._`-._    `-.__.-'    _.-'_.-'|                                   |    `-._`-._        _.-'_.-'    |                                    `-._    `-._`-.__.-'_.-'    _.-'                                         `-._    `-.__.-'    _.-'                                                 `-._        _.-'                                                         `-.__.-'                                               20858:X 28 Mar 2021 21:28:22.568 # WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.20858:X 28 Mar 2021 21:28:22.569 # Sentinel ID is dc245ae88de15c20a29fba857c5f046c27fa6f4420858:X 28 Mar 2021 21:28:22.569 # +monitor master myredis 192.168.137.140 6379 quorum 120858:X 28 Mar 2021 21:28:22.574 * +slave slave 192.168.137.140:6380 192.168.137.140 6380 @ myredis 192.168.137.140 637920858:X 28 Mar 2021 21:28:22.575 * +slave slave 192.168.137.140:6381 192.168.137.140 6381 @ myredis 192.168.137.140 6379</code></pre><p>如果Master节点断开了，这个时候就会从从机中选出一个服务器成为主节点<br><img src="https://edu-2539.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87/20210328213413384.png" alt="iamge"><br><img src="https://edu-2539.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87/20210328213303718.png" alt="image"></p><p>如果主机79恢复了，那也只能成为80的从机</p><h2 id="12-2、哨兵模式的优缺点"><a href="#12-2、哨兵模式的优缺点" class="headerlink" title="12.2、哨兵模式的优缺点"></a>12.2、哨兵模式的优缺点</h2><p>优点1、哨兵集群，基于主从复制模式，所有主从配置的优点，它全有<br>2、主从可以切换，故障可以转移，系统的可用性会更好<br>3、哨兵模式就是主从模式的升级，手动到自动，更加健壮<br>缺点<br>1、Redis不好在线扩容，集群容量一旦达到上限，在线扩容就十分麻烦<br>2、哨兵模式配置麻烦</p><blockquote><p>哨兵模式的全部配置sentinel.conf</p></blockquote><pre><code># Example sentinel.conf # 哨兵sentinel实例运行的端口 默认26379port 26379 # 哨兵sentinel的工作目录dir /tmp # 哨兵sentinel监控的redis主节点的 ip port # master-name  可以自己命名的主节点名字 只能由字母A-z、数字0-9 、这三个字符".-_"组成。# quorum 当这些quorum个数sentinel哨兵认为master主节点失联 那么这时 客观上认为主节点失联了# sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;sentinel monitor mymaster 127.0.0.1 6379 1 # 当在Redis实例中开启了requirepass foobared 授权密码 这样所有连接Redis实例的客户端都要提供密码# 设置哨兵sentinel 连接主从的密码 注意必须为主从设置一样的验证密码# sentinel auth-pass &lt;master-name&gt; &lt;password&gt;sentinel auth-pass mymaster 123  # 指定多少毫秒之后 主节点没有应答哨兵sentinel 此时 哨兵主观上认为主节点下线 默认30秒# sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;sentinel down-after-milliseconds mymaster 30000 # 这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行 同步，这个数字越小，完成failover所需的时间就越长，但是如果这个数字越大，就意味着越 多的slave因为replication而不可用。可以通过将这个值设为 1 来保证每次只有一个slave 处于不能处理命令请求的状态。# sentinel parallel-syncs &lt;master-name&gt; &lt;numslaves&gt;sentinel parallel-syncs mymaster 1   # 故障转移的超时时间 failover-timeout 可以用在以下这些方面： #1. 同一个sentinel对同一个master两次failover之间的间隔时间。#2. 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那里同步数据时。#3.当想要取消一个正在进行的failover所需要的时间。  #4.当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时，slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了# 默认三分钟# sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt;sentinel failover-timeout mymaster 180000 # SCRIPTS EXECUTION #配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知相关人员。#对于脚本的运行结果有以下规则：#若脚本执行后返回1，那么该脚本稍后将会被再次执行，重复次数目前默认为10#若脚本执行后返回2，或者比2更高的一个返回值，脚本将不会重复执行。#如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为1时的行为相同。#一个脚本的最大执行时间为60s，如果超过这个时间，脚本将会被一个SIGKILL信号终止，之后重新执行。 #通知型脚本:当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等等），将会去调用这个脚本，#这时这个脚本应该通过邮件，SMS等方式去通知系统管理员关于系统不正常运行的信息。调用该脚本时，将传给脚本两个参数，#一个是事件的类型，#一个是事件的描述。#如果sentinel.conf配置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执行的，否则sentinel无法正常启动成功。#通知脚本# sentinel notification-script &lt;master-name&gt; &lt;script-path&gt;  sentinel notification-script mymaster /var/redis/notify.sh # 客户端重新配置主节点参数脚本# 当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关的客户端关于master地址已经发生改变的信息。# 以下参数将会在调用脚本时传给脚本:# &lt;master-name&gt; &lt;role&gt; &lt;state&gt; &lt;from-ip&gt; &lt;from-port&gt; &lt;to-ip&gt; &lt;to-port&gt;# 目前&lt;state&gt;总是“failover”,# &lt;role&gt;是“leader”或者“observer”中的一个。 # 参数 from-ip, from-port, to-ip, to-port是用来和旧的master和新的master(即旧的slave)通信的# 这个脚本应该是通用的，能被多次调用，不是针对性的。# sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt;</code></pre><h1 id="13、Redis缓存穿透和雪崩"><a href="#13、Redis缓存穿透和雪崩" class="headerlink" title="13、Redis缓存穿透和雪崩"></a>13、Redis缓存穿透和雪崩</h1><p>Redis缓存的使用，极大的提升了应用程序的性能和效率，特别是数据查询方面。但同时，它也带来了一些问题。其中，最要害的问题就是数据一致性的问题，从严格意义上讲，这个问题无解，如果对数据的一致性要求很高，那么就不能使用缓存</p><h2 id="13-1、Redis缓存穿透（查不到）"><a href="#13-1、Redis缓存穿透（查不到）" class="headerlink" title="13.1、Redis缓存穿透（查不到）"></a>13.1、Redis缓存穿透（查不到）</h2><blockquote><p>概念</p></blockquote><p>缓存穿透的概念很简单，用户想要查询一个数据，发现redis内存数据库没有，也就是缓存没有命中，于是向持久层数据库查询。发现也没有，于是本次查询失败。当用户很多的时候，缓存都没有命中，于是都去请求了持久层数据库，这会给持久层数据库造成很大的压力，这时候就相当于出现了缓存穿透</p><blockquote><p>解决方案</p></blockquote><p>布隆过滤器布隆过滤器是一种数据结构，对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合则丢弃，从而避免了对底层存储系统的压力<br><img src="https://edu-2539.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87/20210328215915118.png" alt="image"></p><p>缓存空对象<br>当存储层不命中后，即使返回的空对象也将其缓存起来，同时会设置一个过期时间，之后再访问这个数据将会从缓存中获取，保护了后端数据源<br><img src="https://edu-2539.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87/20210328220055975.png" alt="image"><br>但是这两种方法会存在两个问题：<br>1、如果空值能够被缓存起来，这就意味着缓存需要更多的空间存储更多的键，因为这当中可能会有很多的空值的键<br>2、即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于需要保持一致性的业务会有影响</p><h2 id="13-2、Redis缓存击穿（量太大，缓存过期）"><a href="#13-2、Redis缓存击穿（量太大，缓存过期）" class="headerlink" title="13.2、Redis缓存击穿（量太大，缓存过期）"></a>13.2、Redis缓存击穿（量太大，缓存过期）</h2><blockquote><p>概述</p></blockquote><p>这里需要注意和缓存击穿的区别，缓存击穿，是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点就行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。</p><p>当某个key在过期的瞬间，有大量的请求并发访问，这类数据一般是热点数据，由于缓存过期，会同时访问数据库来查询最新数据，并且回写缓存，会导致数据库瞬间压力过大</p><blockquote><p>解决方案</p></blockquote><p>设置热点数据永不过期<br>从缓存层面来看，没有设置过期时间，所以不会出现热点key过期后产生的问题<br>加互斥锁<br>分布式锁：使用分布式锁，保证对于灭个key同时只有一个线程去查询后端任务，其他线程没有获得分布式锁的权限，因此只需要等待即可，这种方式将高并发的压力转移到了分布式锁，因此对分布式锁的考验很大</p><h2 id="13-3、Redis缓存雪崩"><a href="#13-3、Redis缓存雪崩" class="headerlink" title="13.3、Redis缓存雪崩"></a>13.3、Redis缓存雪崩</h2><blockquote><p>概念</p></blockquote><p>缓存雪崩，是指在某一个时间段，缓存集中过期失效。Redis宕机</p><p>产生雪崩的原因之一，比如在写文本的时候，马上就要到双十一零点，很快就会迎来一波抢购，这波商品时间比较集中的放入了缓存，假设缓存一个小时，那么到了凌晨一点钟的时候，这批商品的缓存就都过期了。而对这批商品的访问查询，都落到了数据库上，对于数据库而言，就会产生周期性的压力波峰。于是所有的请求都会达到存储层，存储层的调用量会暴增，造车给存储层也会挂掉的情况<br><img src="https://edu-2539.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87/20210328221849605.png" alt="image"></p><blockquote><p>解决方案</p></blockquote><p>redis高可用<br>这个思想的含义是，既然redis有可能挂掉，那我多增加几台redis，这样一台挂掉之后其他的还可以继续工作，其实就是搭建的集群</p><p>限流降级<br>这个解决方案的思想是，在缓存失效后，通过加锁或者队列来控制都数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待</p><p>数据预热<br>数据加热的含义就是在正式部署之前，我先把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中。在即将发生并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀</p><h1 id="鸣谢"><a href="#鸣谢" class="headerlink" title="鸣谢"></a>鸣谢</h1><p>本篇文章均为观看狂神说整理，只作为学习使用</p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis学习 </tag>
            
            <tag> 缓存机制 </tag>
            
            <tag> NoSql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringSecurity学习笔记</title>
      <link href="/2021/10/10/springsecurity-xue-xi-bi-ji/"/>
      <url>/2021/10/10/springsecurity-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="导包"><a href="#导包" class="headerlink" title="导包"></a>导包</h1><pre><code>    &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;            &lt;artifactId&gt;lombok&lt;/artifactId&gt;            &lt;optional&gt;true&lt;/optional&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;            &lt;artifactId&gt;spring-security-test&lt;/artifactId&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;            &lt;artifactId&gt;junit-jupiter&lt;/artifactId&gt;            &lt;version&gt;RELEASE&lt;/version&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;</code></pre><h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringSecurity </tag>
            
            <tag> 安全框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>添加博客记录</title>
      <link href="/2021/10/09/tian-jia-bo-ke-ji-lu/"/>
      <url>/2021/10/09/tian-jia-bo-ke-ji-lu/</url>
      
        <content type="html"><![CDATA[<h1 id="cc-showMessage"><a href="#cc-showMessage" class="headerlink" title="cc_showMessage"></a>cc_showMessage</h1><p> 创建博客文件指令 hexo n 博客名称</p><h2 id="这是一个二级标题"><a href="#这是一个二级标题" class="headerlink" title="这是一个二级标题"></a>这是一个二级标题</h2><p> 几级标题看多少个#号</p><h3 id="这是个三级标题哦"><a href="#这是个三级标题哦" class="headerlink" title="这是个三级标题哦"></a>这是个三级标题哦</h3><ul><li>列表1</li><li>列表2</li><li>列表三<br><a href="https://www.baidu.com/">百度导航</a><h4 id="图片插入"><a href="#图片插入" class="headerlink" title="图片插入"></a>图片插入</h4><img src="https://w.wallhaven.cc/full/72/wallhaven-72rkyv.jpg" alt="图片插入"></li></ul><hr><hr><h3 id="字体编辑"><a href="#字体编辑" class="headerlink" title="字体编辑"></a>字体编辑</h3><p><em>字体是斜线的</em><br><strong>字体加粗</strong></p><h3 id="插入代码"><a href="#插入代码" class="headerlink" title="插入代码"></a>插入代码</h3><p><code>&lt;html&gt;&lt;/html&gt;</code></p><h3 id="多行代码插入"><a href="#多行代码插入" class="headerlink" title="多行代码插入"></a>多行代码插入</h3><pre><code>&lt;html&gt;    &lt;a&gt;        这是一个代码块    &lt;/a&gt;&lt;/html&gt;</code></pre><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><blockquote><p>这是一个引用</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 导航 </tag>
            
            <tag> 分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇博客</title>
      <link href="/2021/10/09/wo-de-di-yi-pian-bo-ke/"/>
      <url>/2021/10/09/wo-de-di-yi-pian-bo-ke/</url>
      
        <content type="html"><![CDATA[<p>简介<br>这是我的第一篇hexo博客。学习从这一刻开始。<br>第一天搭建学习内容<br>hexo s :启动服务器<br>hexo clean ：清理之前缓存<br>hexo g :加载静态内容<br>hexo clean &amp;&amp; hexo g &amp;&amp; hexo s ：可以直接运行这个程序<br>主体的配置主要是在theme的配置文件中<br>hexo d ：上传本地文件到github上<br>hexo n  博客名:创建博客</p>]]></content>
      
      
      
        <tags>
            
            <tag> 博客搭建记录 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
